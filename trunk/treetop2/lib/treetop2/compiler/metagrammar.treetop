module Treetop2
  module Compiler
    grammar Metagrammar
      rule treetop_file
        (grammar / arbitrary_character)* <TreetopFile>
      end

      rule arbitrary_character
        . {
          def compile
            text_value
          end
        }
      end

      rule grammar
        'grammar' space grammar_name space parsing_rule_sequence space? 'end' <Grammar>
      end

      rule grammar_name
        ([A-Z] alphanumeric_char*)
      end

      rule parsing_rule_sequence
        parsing_rule (space parsing_rule)* <ParsingRuleSequence> {
          def rules
            [head_rule] + tail_rules
          end
          
          def head_rule
            elements[0]
          end
          
          def tail_rules
            elements[1].elements.map { |rule_with_space| rule_with_space.elements[1] }
          end
        }
        /
        ''
      end

      rule parsing_rule
        'rule' space nonterminal space parsing_expression space 'end' <ParsingRule>
      end

      rule parsing_expression
        choice / sequence / primary
      end

      rule instantiator
        sequence / instantiator_primary
      end

      rule propagator
        choice / propagator_primary
      end

      rule choice
        alternative (space? '/' space? alternative)+ <Choice> {
          def head_alternative
            elements[0]
          end
          
          def tail_alternatives
            elements[1].elements.map {|alternative_with_slash| alternative_with_slash.elements[3]}
          end
          
          def alternatives
            [head_alternative] + tail_alternatives
          end
        }
      end

      rule sequence
        sequence_primary (space sequence_primary)+ node_class_declarations <Sequence> {
          def head_element
            elements[0]
          end
          
          def tail_elements
            elements[1].elements.map {|element_with_space| element_with_space.elements[1] }
          end
          
          def sequence_elements
            [head_element] + tail_elements
          end
        }
      end

      rule alternative
        sequence / primary
      end

      rule primary
        propagator_primary
        /
        instantiator_primary node_class_declarations {
          def compile(lexical_address, builder)
            instantiator_primary.compile(lexical_address, builder)
          end
        }
      end

      rule sequence_primary
        instantiator_primary / propagator_primary
      end
    
      rule instantiator_primary
        atomic repetition_suffix {
          def compile(lexical_address, builder)
            repetition_suffix.compile(lexical_address, self, builder)
          end
        }
        /
        atomic_instantiator
      end

      rule propagator_primary
        prefix predicated_expression:(instantiator_primary / atomic) {
          def compile(address, builder)
            prefix.compile(address, self, builder)
          end
        }
        /
        (instantiator_primary / atomic) '?' <Optional>
        /
        atomic_propagator
      end
      
      rule node_class_declarations
        node_class_expression trailing_block
      end

      rule repetition_suffix
        '+' <OneOrMore> / '*' <ZeroOrMore>
      end

      rule prefix
        '&' <AndPredicate> / '!' <NotPredicate>
      end

      rule atomic
        atomic_instantiator / atomic_propagator
      end

      rule atomic_instantiator
        terminal / parenthesized_instantiator
      end

      rule atomic_propagator
        nonterminal / parenthesized_propagator
      end
  
      rule parenthesized_instantiator
        '(' space? instantiator space? ')' <ParenthesizedExpression>
      end
  
      rule parenthesized_propagator
        '(' space? propagator space? ')'
      end

      rule nonterminal
        !keyword_inside_grammar (alpha_char alphanumeric_char*) <Nonterminal>
      end

      rule terminal
        single_quoted_string / double_quoted_string / character_class / anything_symbol
      end

      rule double_quoted_string
        '"' (!'"' ("\\\\" / '\"' / .))* '"' <Terminal>
      end

      rule single_quoted_string
        "'" (!"'" ("\\\\" / "\\'" / .))* "'" <Terminal>
      end

      rule character_class
        '[' (!']' ('\]'/.))+ ']' <CharacterClass>
      end

      rule anything_symbol
        '.' <AnythingSymbol>
      end
    
      rule node_class_expression
        space '<' (!'>' .)+ '>'
        /
        ''
      end
  
      rule trailing_block
        space block
        /
        ''
      end

      rule block
        '{' (block / ![{}] .)* '}'
      end

      rule keyword_inside_grammar
        ('rule' / 'end') !non_space_char
      end
  
      rule non_space_char
        !space .
      end

      rule alpha_char
        [A-Za-z_]
      end

      rule alphanumeric_char
        alpha_char / [0-9]
      end
  
      rule space
        [ \t\n\r]+
      end
    end
  end
end