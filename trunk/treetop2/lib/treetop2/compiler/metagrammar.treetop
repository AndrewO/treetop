module Treetop2
  module Compiler
    grammar Metagrammar
      rule treetop_file
        (grammar / arbitrary_character)* <TreetopFile>
      end

      rule arbitrary_character
        . {
          def compile
            text_value
          end
        }
      end

      rule grammar
        'grammar' space grammar_name space parsing_rule_sequence space? 'end' <Grammar>
      end

      rule grammar_name
        ([A-Z] alphanumeric_char*)
      end

      rule parsing_rule_sequence
        parsing_rule (space parsing_rule)* <ParsingRuleSequence> {
          def rules
            [head_rule] + tail_rules
          end
          
          def head_rule
            elements[0]
          end
          
          def tail_rules
            elements[1].elements.map { |rule_with_space| rule_with_space.elements[1] }
          end
        }
        /
        ''
      end

      rule parsing_rule
        'rule' space nonterminal space parsing_expression space 'end' <ParsingRule>
      end

      rule parsing_expression
        choice / sequence / primary
      end

      rule choice
        alternative (space? '/' space? alternative)+ <Choice> {
          def head_alternative
            elements[0]
          end
          
          def tail_alternatives
            elements[1].elements.map {|alternative_with_slash| alternative_with_slash.elements[3]}
          end
          
          def alternatives
            [head_alternative] + tail_alternatives
          end
          
          def inline_module_nodes
            (alternatives.map {|alt| alt.inline_module_nodes }).flatten
          end
        }
      end

      rule sequence
        sequence_primary (space sequence_primary)+ node_class_declarations <Sequence> {
          def head_element
            elements[0]
          end
          
          def tail_elements
            elements[1].elements.map {|element_with_space| element_with_space.elements[1] }
          end
          
          def sequence_elements
            [head_element] + tail_elements
          end
          
          def inline_module_nodes
            (sequence_elements.map {|elt| elt.inline_module_nodes}).flatten + node_class_declarations.inline_module_nodes
          end
        }
      end

      rule alternative
        sequence / primary
      end

      rule primary
        prefix atomic {
          def compile(address, builder)
            prefix.compile(address, builder, self)
          end
          
          def predicated_expression
            atomic
          end
          
          def inline_module_nodes
            atomic.inline_module_nodes
          end
          
          def inline_module
            nil
          end
        }
        /
        atomic suffix node_class_declarations {
          def compile(address, builder)
            suffix.compile(address, builder, self)
          end
          
          def optional_expression
            elements[0]
          end
          
          def node_class
            node_class_declarations.node_class || 'SequenceSyntaxNode'
          end
          
          def inline_module_nodes
            node_class_declarations.inline_module_nodes
          end
          
          def inline_module
            node_class_declarations.inline_module
          end
        }
        /
        atomic node_class_declarations {
          def compile(address, builder)
            atomic.compile(address, builder, self)
          end
          
          def node_class
            node_class_declarations.node_class
          end
          
          def inline_module_nodes
            node_class_declarations.inline_module_nodes
          end
          
          def inline_module
            node_class_declarations.inline_module
          end
        }
      end

      rule sequence_primary
        prefix atomic {
          def compile(lexical_address, builder)
            prefix.compile(lexical_address, builder, self)
          end
          
          def predicated_expression
            elements[1]
          end
          
          def inline_module_nodes
            atomic.inline_module_nodes
          end
          
          def inline_module
            nil
          end
        }
        /
        atomic suffix {
          def compile(lexical_address, builder)
            suffix.compile(lexical_address, builder, self)
          end
          
          def node_class
            'SequenceSyntaxNode'
          end
          
          def inline_module_nodes
            atomic.inline_module_nodes
          end
          
          def inline_module
            nil
          end
        }
        /
        atomic
      end
      
      rule suffix
        repetition_suffix / optional_suffix
      end
      
      rule optional_suffix
        '?' <Optional>
      end
          
      rule node_class_declarations
        node_class_expression trailing_block {
          def node_class
            node_class_expression.node_class
          end
          
          def inline_module_nodes
            trailing_block.inline_module_nodes
          end
          
          def inline_module_node
            trailing_block.inline_module_node
          end
          
          def inline_module
            inline_module_node.module_name if inline_module_node
          end
        }
      end

      rule repetition_suffix
        '+' <OneOrMore> / '*' <ZeroOrMore>
      end

      rule prefix
        '&' <AndPredicate> / '!' <NotPredicate>
      end

      rule atomic
        terminal
        /
        nonterminal
        /
        parenthesized_expression
      end
  
      rule parenthesized_expression
        '(' space? parsing_expression space? ')' <ParenthesizedExpression> {
          def inline_module_nodes
            parsing_expression.inline_module_nodes
          end
        }
      end
  
      rule nonterminal
        !keyword_inside_grammar (alpha_char alphanumeric_char*) <Nonterminal>
      end

      rule terminal
        single_quoted_string / double_quoted_string / character_class / anything_symbol
      end

      rule double_quoted_string
        '"' (!'"' ("\\\\" / '\"' / .))* '"' <Terminal> {
          def inline_module_nodes
            []
          end
        }
      end

      rule single_quoted_string
        "'" (!"'" ("\\\\" / "\\'" / .))* "'" <Terminal> {
          def inline_module_nodes
            []
          end
        }
      end

      rule character_class
        '[' (!']' ('\]'/.))+ ']' <CharacterClass> {
          def inline_module_nodes
            []
          end
        }
      end

      rule anything_symbol
        '.' <AnythingSymbol> {
          def inline_module_nodes
            []
          end
        }
      end
    
      rule node_class_expression
        space '<' (!'>' .)+ '>' {
          def node_class
            elements[2].text_value
          end
        }
        /
        '' {
          def node_class
            nil
          end
        }
      end
  
      rule trailing_block
        space block {
          def inline_module_nodes
            [inline_module_node]
          end
          
          def inline_module_node
            block
          end
          
          def inline_module
            inline_module_node.module_name
          end
        }
        /
        '' {
          def inline_module_nodes
            []
          end
          
          def inline_module_node
            nil 
          end
          
          def inline_module
            nil
          end
        }
      end

      rule block
        '{' (block / ![{}] .)* '}' <InlineModule>
      end

      rule keyword_inside_grammar
        ('rule' / 'end') !non_space_char
      end
  
      rule non_space_char
        !space .
      end

      rule alpha_char
        [A-Za-z_]
      end

      rule alphanumeric_char
        alpha_char / [0-9]
      end
  
      rule space
        [ \t\n\r]+
      end
    end
  end
end