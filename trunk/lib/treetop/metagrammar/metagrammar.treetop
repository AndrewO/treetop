grammar Metagrammar
  rule grammar
    ('grammar' space grammar_name parsing_rule_sequence space? 'end') {
      def to_ruby
        "#{name} = Grammar.new('#{name}')\n#{parsing_rule_sequence.to_ruby(self)}"
      end
      
      def name
        elements[2].value
      end
      
      def parsing_rule_sequence
        elements[3]
      end
    }
  end

  rule grammar_name
    ([A-Z] alphanumeric_char*) space {
      def value
        elements[0].text_value.to_sym
      end
    }
  end
  
  rule parsing_rule_sequence
    (parsing_rule (space parsing_rule)*) {
      def to_ruby(grammar_node)
        add_rules_ruby = rules.map {|rule| rule.add_rule_ruby(grammar_node)}
        add_rules_ruby.join("\n") + "\n"
      end

      def rules
        [head_rule] + tail_rules
      end
      
      def head_rule
        elements[0]
      end
          
      def tail_rules
        elements[1].elements.map {|space_parsing_rule_sequence| space_parsing_rule_sequence.elements[1]}
      end
    }
    /
    '' {
      def to_ruby(grammar)
        ''
      end
    }
  end
  
  rule parsing_rule
    ('rule' space nonterminal space expression space 'end') {
      def to_ruby(grammar_node)
        "ParsingRule.new(#{nonterminal.to_ruby(grammar_node)}, #{expression.to_ruby(grammar_node)})"
      end
       
      def add_rule_ruby(grammar_node)
        "#{grammar_node.name}.add_parsing_rule(#{to_ruby(grammar_node)})"
      end

      def nonterminal
         elements[2]
      end
      
      def expression
         elements[4]
      end
    }
  end
  
  rule expression
    choice / sequence / primary
  end

  rule instantiator
    sequence / instantiator_primary
  end
  
  rule propagator
    choice / propagator_primary
  end

  rule choice
    (alternative (space? '/' space? alternative)+) {
      def to_ruby(grammar_node)
        alternatives_ruby = alternatives.map { |alternative| alternative.to_ruby(grammar_node) }
        "OrderedChoice.new([#{alternatives_ruby.join(', ')}])"
      end
      
      def alternatives
        [head_alternative] + tail_alternatives
      end
      
      def head_alternative
        elements[0]
      end
      
      def tail_alternatives
        elements[1].elements.map {|tail_element| tail_element.elements[3]}
      end
    }
  end

  rule sequence
    primary (space primary)+ trailing_block {
      def to_ruby(grammar_node)
        elements_ruby = sequence_elements.map {|element| element.to_ruby(grammar_node)}
        "Sequence.new([#{elements_ruby.join(', ')}])#{trailing_block.to_ruby}"
      end
    
      def sequence_elements
        [head_element] + tail_elements
      end
      
      def head_element
        elements[0]
      end
      
      def tail_elements
        elements[1].elements.map {|tail_element| tail_element.elements[1]}
      end
      
      def trailing_block
        elements[2]
      end
    }
  end
  
  rule alternative
    sequence / primary
  end

  rule primary
    instantiator_primary trailing_block {
      def to_ruby(grammar_node)
        "#{instantiator_primary.to_ruby(grammar_node)}#{trailing_block.to_ruby}"
      end
      
      def instantiator_primary
        elements[0]
      end
      
      def trailing_block
        elements[1]
      end
    }
    /
    propagator_primary
  end

  rule instantiator_primary
    atomic repetition_suffix {
      def to_ruby(grammar_node)
        repetition_suffix.to_ruby(grammar_node, atomic)
      end
      
      def atomic
        elements[0]
      end
      
      def repetition_suffix
        elements[1]
      end
    }
    /
    atomic_instantiator
  end
  
  rule propagator_primary
    (prefix (instantiator_primary / atomic)) {
      def to_ruby(grammar_node)
        prefix.to_ruby(grammar_node, prefixed_expression)
      end
      
      def prefix
        elements[0]
      end
      
      def prefixed_expression
        elements[1]
      end
    }
    /
    ((instantiator_primary / atomic) '?') {
      def to_ruby(grammar_node)
        "Optional.new(#{optional_expression.to_ruby(grammar_node)})"
      end
    
      def optional_expression
        elements[0]
      end
    }
    /
    atomic_propagator
  end
  
  rule repetition_suffix
    '+' {
      def to_ruby(grammar_node, repeated_expression)
        "OneOrMore.new(#{repeated_expression.to_ruby(grammar_node)})"
      end
    }
    /
    '*' {
      def to_ruby(grammar_node, repeated_expression)
        "ZeroOrMore.new(#{repeated_expression.to_ruby(grammar_node)})"
      end
    }
  end
  
  rule prefix
    '&' {
      def to_ruby(grammar_node, prefixed_expression)
        "AndPredicate.new(#{prefixed_expression.to_ruby(grammar_node)})"
      end
    }
    /
    '!' {
      def to_ruby(grammar_node, prefixed_expression)
        "NotPredicate.new(#{prefixed_expression.to_ruby(grammar_node)})"
      end
    }
  end

  rule atomic
    atomic_instantiator / atomic_propagator
  end

  rule atomic_instantiator
    terminal / parenthesized_instantiator
  end

  rule atomic_propagator
    nonterminal / parenthesized_propagator
  end
  
  rule parenthesized_instantiator
    ('(' space? instantiator space? ')') {
      def to_ruby(grammar_node)
        instantiator.to_ruby(grammar_node)
      end
      
      def instantiator
        elements[2]
      end
    }
  end
  
  rule parenthesized_propagator
    ('(' space? propagator space? ')') {
      def to_ruby(grammar_node)
        propagator.to_ruby(grammar_node)
      end
      
      def propagator
        elements[2]
      end
    }
  end

  rule nonterminal
    (!keyword (alpha_char alphanumeric_char*)) {
      def name
        elements[1].text_value
      end
      
      def to_ruby(grammar_node)
        "#{grammar_node.name}.nonterminal_symbol(:#{name})"
      end
    }
  end

  rule terminal
    single_quoted_string / double_quoted_string / character_class / anything_symbol
  end

  rule double_quoted_string
    ('"' (!'"' ('\"' / .))* '"') {
      def to_ruby(grammar_node = nil)
        "TerminalSymbol.new(\"#{elements[1].text_value}\")"
      end
    }
  end

  rule single_quoted_string
    ("'" (!"'" ("\\'" / .))* "'") {
      def to_ruby(grammar_node = nil)
        "TerminalSymbol.new('#{elements[1].text_value}')"
      end
    }
  end

  rule character_class
    ('[' (!']' ('\]'/.))+ ']') {
      def to_ruby(grammar_node = nil)
        "CharacterClass.new('#{characters}')"
      end
      
      def characters
        elements[1].text_value
      end
    }
  end

  rule anything_symbol
    '.' {
      def to_ruby(grammar_node = nil)
        'AnythingSymbol.new'
      end
    }
  end
  
  rule trailing_block
    space block {
      def to_ruby
        " #{block.to_ruby}"
      end

      def block
        elements[1]
      end
    }
    /
    '' {
      def to_ruby
        ''
      end
    }
  end

  rule block
    ('{' (block / ![{}] .)* '}') {
      def to_ruby
        text_value
      end    
    }
  end

  rule keyword
    ('rule' / 'end') !(!space .)
  end

  rule alpha_char
    [A-Za-z_]
  end

  rule alphanumeric_char
    alpha_char / [0-9]
  end
  
  rule space
    [ \t\n\r]+
  end
end