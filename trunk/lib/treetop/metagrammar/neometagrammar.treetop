grammar Metagrammar
  rule trailing_block
    space block {
      def to_ruby(preceding_expression_ruby_source)
        "#{preceding_expression_ruby_source} #{block.to_ruby}"
      end

      def block
        elements[1]
      end
    }
    /
    '' {
      def to_ruby(preceding_expression_ruby_source)
        preceding_expression_ruby_source
      end
    }
  end

  rule block
    ('{' (block / ![{}] .)* '}') {
      def to_ruby
        first_character = block_contents[0]
        last_character = block_contents[-1]
    
        "do#{newline_if_needed(first_character)}#{block_contents}#{newline_if_needed(last_character)}end"
      end
    
      def block_contents
        elements[1].text_value
      end
    
      def newline_if_needed(character)
        character == 10 ? "" : "\n"
      end
    }
  end

  rule nonterminal_symbol
    (!keyword (alpha_char alphanumeric_char*)) {
      def name
        elements[1].text_value
      end
      
      def to_ruby(grammar_node)
        "#{grammar_node.name}.nonterminal_symbol(:#{name})"
      end
    }
  end

  rule terminal_symbol
    single_quoted_string / double_quoted_string / character_class / anything_symbol
  end

  rule double_quoted_string
    ('"' (!'"' ('\"' / .))* '"') {
      def to_ruby
        "TerminalSymbol.new(\"#{elements[1].text_value}\")"
      end
    }
  end

  rule single_quoted_string
    ("'" (!"'" ("\\'" / .))* "'") {
      def to_ruby
        "TerminalSymbol.new('#{elements[1].text_value}')"
      end
    }
  end

  rule character_class
    ('[' (!']' ('\]'/.))+ ']') {
      def to_ruby
        "CharacterClass.new('#{characters}')"
      end
      
      def characters
        elements[1].text_value
      end
    }
  end

  rule anything_symbol
    '.' {
      def to_ruby
        'AnythingSymbol.new'
      end
    }
  end
  
  rule keyword
    ('rule' / 'end') !(!space .)
  end

  rule alpha_char
    [A-Za-z_]
  end

  rule alphanumeric_char
    alpha_char / [0-9]
  end
  
  rule space
    [ \t\n\r]+
  end
end