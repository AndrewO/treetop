grammar Metagrammar

  rule grammar
    ('grammar' space grammar_name parsing_rule_sequence space? 'end') {
      def to_ruby
        "#{name} = Grammar.new('#{name}')\n#{parsing_rule_sequence.to_ruby(self)}"
      end
      
      def name
        elements[2].value
      end
      
      def parsing_rule_sequence
        elements[3]
      end
    }
  end

  rule grammar_name
    ([A-Z] alphanumeric_char*) space {
      def value
        elements[0].text_value.to_sym
      end
    }
  end

  rule parsing_rule_sequence
    (parsing_rule (space parsing_rule)*) {
      def to_ruby(grammar_node)
        add_rules_ruby = rules.map {|rule| rule.add_rule_ruby(grammar_node)}
        add_rules_ruby.join("\n") + "\n"
      end

      def rules
        [head_rule] + tail_rules
      end
      
      def head_rule
        elements[0]
      end
          
      def tail_rules
        elements[1].elements.map {|space_parsing_rule_sequence| space_parsing_rule_sequence.elements[1]}
      end
    }
    /
    '' {
      def to_ruby(grammar)
        ''
      end
    }
  end

  rule parsing_rule
    ('rule' space nonterminal_symbol space ordered_choice space 'end') {
      def to_ruby(grammar_node)
        "ParsingRule.new(#{nonterminal_symbol.to_ruby(grammar_node)}, #{parsing_expression.to_ruby(grammar_node)})"
      end
       
      def add_rule_ruby(grammar_node)
        "#{grammar_node.name}.add_parsing_rule(#{to_ruby(grammar_node)})"
      end

      def nonterminal_symbol
         elements[2]
      end
      
      def parsing_expression
         elements[4]
      end
    }
  end

  rule ordered_choice
    (sequence (space? '/' space? sequence)+) {
      def to_ruby(grammar_node)
        alternatives_ruby = alternatives.map {|alternative| alternative.to_ruby(grammar_node)}
        "OrderedChoice.new([#{alternatives_ruby.join(', ')}])"
      end

      def alternatives
        [head_alternative] + tail_alternatives
      end
    
      def head_alternative
        elements[0]
      end
    
      def tail_alternatives
        elements[1].elements.map {|repeated_tail_sequence| repeated_tail_sequence.elements[3]}
      end
    }
    /
    sequence
  end

  rule sequence
    (primary (space primary)+ trailing_block) {
      
      def to_ruby(grammar_node)      
        elements_ruby = sequence_elements.map {|element| element.to_ruby(grammar_node)}
        sequence_ruby = "Sequence.new([#{elements_ruby.join(', ')}])"        
        trailing_block.to_ruby(sequence_ruby)
      end
      
      def sequence_elements
        [head_element] + tail_elements
      end

      def head_element
        elements[0]
      end

      def tail_elements
        elements[1].elements.map {|space_primary_sequence| space_primary_sequence.elements[1]}
      end
      
      def trailing_block
        elements[2]
      end
    }
    /
    primary
  end

  rule parenthesized_ordered_choice
    '(' space? ordered_choice space? ')' trailing_block {
      def to_ruby(grammar_node)
        trailing_block.to_ruby(nested_expression.to_ruby(grammar_node))
      end

      def nested_expression
        elements[2]
      end
 
      def trailing_block
        elements[5]
      end
    }
  end

  rule primary
    (prefix? ((parenthesized_ordered_choice / terminal_symbol / nonterminal_symbol) suffix?)) {
      def to_ruby(grammar_node)
        ruby_source = primary_expression.to_ruby(grammar_node)
        ruby_source = suffix.to_ruby(ruby_source) unless suffix.epsilon?
        ruby_source = prefix.to_ruby(ruby_source) unless prefix.epsilon?
        ruby_source
      end

      def prefix
        elements[0]
      end
    
      def primary_expression
        elements[1].elements[0]
      end
    
      def suffix
        elements[1].elements[1]
      end
    }
  end  
  
  rule prefix
    '&' {
      def to_ruby(subsequent_expression_ruby_source)
        "AndPredicate.new(#{subsequent_expression_ruby_source})"
      end
    }
    /
    '!' {
      def to_ruby(subsequent_expression_ruby_source)
        "NotPredicate.new(#{subsequent_expression_ruby_source})"
      end
    }
  end

  rule suffix
    '*' {
      def to_ruby(preceding_expression_ruby_source)
        "ZeroOrMore.new(#{preceding_expression_ruby_source})"
      end
    }
    /
    '+' {
      def to_ruby(preceding_expression_ruby_source)
        "OneOrMore.new(#{preceding_expression_ruby_source})"
      end
    }
    /
    '?' {
      def to_ruby(preceding_expression_ruby_source)
        "Optional.new(#{preceding_expression_ruby_source})"
      end
    }
  end
  
  rule nonterminal_symbol
    (!keyword (alpha_char alphanumeric_char*)) {
      def name
        elements[1].text_value
      end
      
      def to_ruby(grammar_node)
        "#{grammar_node.name}.nonterminal_symbol(:#{name})"
      end
    }
  end

  rule alpha_char
    [A-Za-z_]
  end

  rule alphanumeric_char
    alpha_char / [0-9]
  end

  rule terminal_symbol
    terminal_symbol_prefix trailing_block {
      def to_ruby(grammar_node = nil)
        trailing_block.to_ruby(terminal_symbol.to_ruby)
      end

      def terminal_symbol
        elements[0]
      end
     
      def trailing_block
        elements[1]
      end
    }
  end

  rule terminal_symbol_prefix
    single_quoted_string / double_quoted_string / character_class / anything_symbol
  end

  rule double_quoted_string
    ('"' (!'"' ('\"' / .))* '"') {
      def to_ruby
        "TerminalSymbol.new(\"#{elements[1].text_value}\")"
      end
    }
  end

  rule single_quoted_string
    ("'" (!"'" ("\\'" / .))* "'") {
      def to_ruby
        "TerminalSymbol.new('#{elements[1].text_value}')"
      end
    }
  end

  rule trailing_block
    space block {
      def to_ruby(preceding_expression_ruby_source)
        "#{preceding_expression_ruby_source} #{block.to_ruby}"
      end

      def block
        elements[1]
      end
    }
    /
    '' {
      def to_ruby(preceding_expression_ruby_source)
        preceding_expression_ruby_source
      end
    }
  end
  
  rule block
    ('{' (block / ![{}] .)* '}') {
      def to_ruby
        first_character = block_contents[0]
        last_character = block_contents[-1]
      
        "do#{newline_if_needed(first_character)}#{block_contents}#{newline_if_needed(last_character)}end"
      end
      
      def block_contents
        elements[1].text_value
      end
      
      def newline_if_needed(character)
        character == 10 ? "" : "\n"
      end
    }
  end

  rule character_class
    ('[' (!']' ('\]'/.))+ ']') {
      def to_ruby
        "CharacterClass.new('#{characters}')"
      end
      
      def characters
        elements[1].text_value
      end
    }
  end
  
  rule keyword
    ('rule' / 'end') !(!space .)
  end

  rule anything_symbol
    '.' {
      def to_ruby
        'AnythingSymbol.new'
      end
    }
  end
  
  rule space
    [ \t\n\r]+
  end
end