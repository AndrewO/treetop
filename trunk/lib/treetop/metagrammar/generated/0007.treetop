require "#{TREETOP_ROOT}/metagrammar/node_classes_2"

module Treetop
  grammar Metagrammar
    rule treetop_file
      (grammar / arbitrary_character)* <MetagrammarNode::TreetopFile>
    end

    rule arbitrary_character
      . <MetagrammarNode::ArbitraryCharacter>
    end

    rule grammar
      'grammar' space grammar_name parsing_rule_sequence space? 'end' <MetagrammarNode::GrammarNode>
    end

    rule grammar_name
      ([A-Z] alphanumeric_char*) space <MetagrammarNode::GrammarName>
    end

    rule parsing_rule_sequence
      head_rule:parsing_rule tail_rules:(space parsing_rule)* <MetagrammarNode::ParsingRuleSequence>
      /
      '' <MetagrammarNode::Epsilon>
    end

    rule parsing_rule
      'rule' space nonterminal space parsing_expression space 'end' <MetagrammarNode::ParsingRuleNode>
    end

    rule parsing_expression
      choice / sequence / primary
    end

    rule instantiator
      sequence / instantiator_primary
    end

    rule propagator
      choice / propagator_primary
    end

    rule choice
      head_alternative:alternative (space? '/' space? alternative)+ <MetagrammarNode::Choice>
    end

    rule sequence
      head_element:blockless_primary (space blockless_primary)+ node_class_expression trailing_block <MetagrammarNode::Sequence>
    end

    rule alternative
      sequence / primary
    end

    rule primary
      label labelless_primary <MetagrammarNode::LabeledPrimary>
      /
      labelless_primary
    end

    rule label
      (alpha_char alphanumeric_char*) ':' {
        def to_ruby
          ".labeled_as(:#{elements[0].text_value})"
        end
      }
    end
    
    rule labelless_primary
      instantiator_primary node_class_expression trailing_block <MetagrammarNode::Primary>
      /
      propagator_primary
    end

    rule blockless_primary
      label (labelless_blockless_primary) <MetagrammarNode::LabeledPrimary>
      /
      labelless_blockless_primary
    end
    
    rule labelless_blockless_primary
      instantiator_primary / propagator_primary
    end

    rule instantiator_primary
      atomic repetition_suffix <MetagrammarNode::InstantiatorPrimary>
      /
      atomic_instantiator
    end

    rule propagator_primary
      prefix (instantiator_primary / atomic) <MetagrammarNode::PrefixedPrimary>
      /
      (instantiator_primary / atomic) '?' <MetagrammarNode::OptionalPrimary>
      /
      atomic_propagator
    end

    rule repetition_suffix
      '+' <MetagrammarNode::Plus> / '*' <MetagrammarNode::Star>
    end

    rule prefix
      '&' <MetagrammarNode::And> / '!' <MetagrammarNode::Bang>
    end

    rule atomic
      atomic_instantiator / atomic_propagator
    end

    rule atomic_instantiator
      terminal / parenthesized_instantiator
    end

    rule atomic_propagator
      nonterminal / parenthesized_propagator
    end
  
    rule parenthesized_instantiator
      '(' space? instantiator space? ')' <MetagrammarNode::ParenthesizedInstantiator>
    end
  
    rule parenthesized_propagator
      '(' space? propagator space? ')' <MetagrammarNode::ParenthesizedPropagator>
    end

    rule nonterminal
      !keyword_inside_grammar (alpha_char alphanumeric_char*) <MetagrammarNode::Nonterminal>
    end

    rule terminal
      single_quoted_string / double_quoted_string / character_class / anything_symbol
    end

    rule double_quoted_string
      '"' (!'"' ("\\\\" / '\"' / .))* '"' <MetagrammarNode::DoubleQuotedString>
    end

    rule single_quoted_string
      "'" (!"'" ("\\\\" / "\\'" / .))* "'" <MetagrammarNode::SingleQuotedString>
    end

    rule character_class
      '[' (!']' ('\]'/.))+ ']' <MetagrammarNode::CharacterClass>
    end

    rule anything_symbol
      '.' <MetagrammarNode::AnythingSymbol>
    end
    
    rule node_class_expression
      space '<' (!'>' .)+ '>' <MetagrammarNode::NodeClassExpression>
      /
      '' <MetagrammarNode::Epsilon>
    end
  
    rule trailing_block
      space block <MetagrammarNode::TrailingBlock>
      /
      '' <MetagrammarNode::Epsilon>
    end

    rule block
      '{' (block / ![{}] .)* '}' <MetagrammarNode::Block>
    end

    rule keyword_inside_grammar
      ('rule' / 'end') !non_space_char
    end
  
    rule non_space_char
      !space .
    end

    rule alpha_char
      [A-Za-z_]
    end

    rule alphanumeric_char
      alpha_char / [0-9]
    end
  
    rule space
      [ \t\n\r]+
    end
  end
end