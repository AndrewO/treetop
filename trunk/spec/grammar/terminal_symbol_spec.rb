require 'rubygems'
require 'spec'

dir = File.dirname(__FILE__)
require "#{dir}/../spec_helper"

context "A terminal symbol" do
  setup do
    @terminal = TerminalSymbol.new("foo")
  end
    
  specify "returns the correct interval for a prefix starting after 0" do
    result = @terminal.parse_at("xfoo", 1, parser_with_empty_cache_mock)
    result.interval.should eql 1...4
    
    result = @terminal.parse_at("---foo", 3, parser_with_empty_cache_mock)
    result.interval.should eql 3...6
  end
  
  specify "shouldn't parse nonmatching input at the index even if a match occurs later in the input" do
    @terminal.parse_at(" foo", 0, parser_with_empty_cache_mock).should be_failure
  end
  
  specify "has a string representation" do
    @terminal.to_s.should == '"foo"'
  end
end

context "The result of TerminalSymbol#parse_at for a matching input prefix at a given index" do
  setup do
    @terminal = TerminalSymbol.new("foo")
    @parser = parser_with_empty_cache_mock
    input = ("foobar")
    @result = @terminal.parse_at(input, 0, @parser)
  end
  
  specify "is an instance of SuccessfulParseResult" do
    @result.should be_success
  end
  
  specify "is successful" do
    @result.should be_success
  end
  
  specify "has a text value matching the terminal symbol" do
    @result.value.text_value.should eql @terminal.prefix
  end
  
  specify "is a kind of TerminalSyntaxNode" do
    @result.value.should be_a_kind_of TerminalSyntaxNode
  end
end

context "The result of TerminalSymbol#parse_at for a non-matching input prefix at a given index" do
  setup do
    @terminal = TerminalSymbol.new("foo")
    @parser = parser_with_empty_cache_mock
    input = ("barfoo")
    @start_index = 0
    @result = @terminal.parse_at(input, @start_index, @parser)
  end
  
  specify "is an instance of of FailedParseResult" do
    @result.should be_an_instance_of(FailedParseResult)
  end
  
  specify "has a consumed interval that start and end at the start index of the parse" do
    @result.interval.should == (@start_index...@start_index)    
  end
  
  specify "has one failure tree that is also a failure leaf that has a reference back to the failing terminal" do
    failure_leaf = @result.failure_tree
    failure_leaf.should be_a_kind_of(FailureTree)    
    failure_leaf.should be_an_instance_of(FailureLeaf)
    failure_leaf.expression.should == @terminal
  end
end

context "A terminal symbol with a method defined in its node class" do
  setup do
    @terminal = TerminalSymbol.new("foo")
    @terminal.node_class_eval do
      def method
      end
    end
  end
  
  specify "returns nodes that have that method on a successful parse" do
    input = @terminal.prefix
    index = 0
    parser = parser_with_empty_cache_mock
    
    result = @terminal.parse_at(input, index, parser)
    result.should be_success
    result.should respond_to :method
  end
end

context "A terminal symbol matching 'end'" do
  setup do
    @terminal = TerminalSymbol.new('end')
  end
  specify "shold not match anything other than end" do
    input = "crack\nend"
    @terminal.parse_at(input, 0, parser_with_empty_cache_mock).should be_failure
  end
end

context "A terminal symbol generated by TerminalSymbol.epsilon" do
  setup do
    @terminal = TerminalSymbol.epsilon
  end
  
  specify "should be epsilon" do
    @terminal.should be_epsilon
  end
end