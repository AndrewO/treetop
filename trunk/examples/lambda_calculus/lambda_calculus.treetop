grammar LambdaCalculus
  include Arithmetic

  rule expression
    application / function / super
  end
  
  rule primary
    application / super
  end

  rule application
    operator space expression <Application> {
      def eval(env={})
        left_associative_apply(operator.eval(env), env)
      end
      
      def left_associative_apply(operator, env)
        if expression.instance_of?(Application)
          expression.left_associative_apply(operator.apply(expression.operator.eval(env)), env)
        else
          operator.apply(expression.eval(env))
        end
      end
      
      def to_s(env={})
        operator.to_s(env) + ' ' + expression.to_s(env)
      end
    }
  end
  
  rule operator
    function / variable
  end
  
  rule non_application
    function / variable
  end
  
  rule function
    '\\' param:variable '[' body:expression ']' {
      class Closure
        attr_reader :env, :function
        
        def initialize(function, env)
          @function = function
          @env = env
        end
      
        def apply(arg)
          function.body.eval(function.param.bind(arg, env))
        end
      
        def to_s(other_env={})
          "\\#{function.param.to_s}[#{function.body.to_s(other_env.merge(env))}]"
        end
      end
      
      def eval(env={})
        Closure.new(self, env)
      end
      
      def to_s(env={})
        eval(env).to_s
      end
    }
  end
  
  rule variable
    [a-z] {
      def eval(env={})
        env[name] || self
      end
      
      def bind(value, env)
        env.merge(name => value)
      end
      
      def name
        text_value
      end
      
      def to_s(env={})
        env[name] ? env[name].to_s : name
      end
    }
  end
  
  rule space
    [ \n]*
  end
end