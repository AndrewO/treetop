grammar LambdaCalculus
  rule expression
    application / function / variable
  end

  rule application
    operator space expression <Application> {
      def eval(env={})
        left_associative_apply(operator.eval(env), env)
      end
      
      def left_associative_apply(operator, env)
        if expression.instance_of?(Application)
          expression.left_associative_apply(operator.apply(expression.operator.eval(env)), env)
        else
          operator.apply(expression.eval(env))
        end
      end
      
      def to_s
        text_value
      end
    }
  end
  
  rule operator
    function / variable
  end
  
  rule non_application
    function / variable
  end
  
  rule function
    '\\' param:variable '[' body:expression ']' {
      class Closure
        attr_reader :env, :function
        
        def initialize(function, env)
          @function = function
          @env = env
        end
      
        def apply(arg)
          function.body.eval(function.param.bind(arg, env))
        end
      
        def to_s
          function.to_s + ' ' + env.inspect
        end
      end
      
      def eval(env={})
        Closure.new(self, env)
      end
      
      def to_s
        text_value
      end
    }
  end
  
  rule variable
    [a-z] {
      def eval(env={})
        env[to_s] || self
      end
      
      def bind(value, env)
        env.merge(to_s => value)
      end
      
      def to_s
        text_value
      end
    }
  end
  
  rule space
    [ \n]*
  end
end